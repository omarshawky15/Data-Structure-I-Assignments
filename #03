package eg.edu.alexu.csd.datastructure.iceHockey;
import java.awt.*;
import java.util.*;
import java.lang.* ;
interface IPlayersFinder {
	java.awt.Point []  findPlayers(String[] photo, int team, int threshold);
}
public class Cs implements IPlayersFinder {
	public java.awt.Point []  findPlayers(String[] photo, int team, int threshold){
		String[] photoTemp = new String[photo.length] ;
		photoTemp = photo ;
		ArrayList<ArrayList<Integer>> pointsarr = new ArrayList<ArrayList<Integer>>() ;
		int counter =0 ;
		for(int i=0 ; i<photo.length ; i++) {
			for(int j=0 ; j< photo[i].length() ; j++) {
				int [] arr1 = {0,0,0,0,0} ;
				if (photo[i].charAt(j) -48  == team) {
					arr1=directions(photo,i,j,team , 1);
				}
				if (arr1[0] *4 >= threshold) {
					pointsarr.add(new ArrayList<Integer>());
					pointsarr.get(counter).add(arr1[2]+arr1[4]+1);
					pointsarr.get(counter).add(arr1[1]+arr1[3]+1);
					counter++;
				}
			}
		}
		sort(pointsarr);
		Point []  omar = new Point [pointsarr.size()];
		for(int i =0 ; i<pointsarr.size(); i++) {
			omar[i] = new Point() ;
			omar[i].setLocation(pointsarr.get(i).get(0),pointsarr.get(i).get(1));
		}
		//returning photo to its original cuz it's now all full of "x"'s :p 
		photo = photoTemp ;
		return omar ; 
	}
	
	//function to - i named it cuz its like arrow keys ->_<- - go in all directions of "int" team as long as it finds one 
	public int[] directions (String[] photo, int row , int column ,int target,int counter) {
		int [] arr1 = {counter ,   row , column ,row , column } ;
		int [] arrtemp = {-1,0,0};
		if(row>=photo.length || column >= photo[0].length() 
			|| row<0 || column < 0
			|| (int)photo[row].charAt(column)-48 != target ) {
			return arrtemp ;
		}
		arrtemp[0] = counter ;
		// marking/replacing the visited number with x 
		photo[row] =photo[row].substring(0,column) + 'x' + photo[row].substring(column+1) ;
		//down-arrow key
		arrtemp = directions( photo, row+1 , column,target,counter+1);
		if (arrtemp[0] != -1 ) {
			arr1[0] = Math.max(arr1[0], arrtemp[0]);
			counter = arr1[0];
			arr1[1] = Math.max(arr1[1], arrtemp[1]);
			arr1[2] = Math.max(arr1[2], arrtemp[2]);
			arr1[3] = Math.min(arr1[3], arrtemp[3]);
			arr1[4] = Math.min(arr1[4], arrtemp[4]);
			
		}
		//up-arrow key
		arrtemp = directions( photo, row-1 , column,target,counter+1);
		if (arrtemp[0] != -1 ) {
			arr1[0] = Math.max(arr1[0], arrtemp[0]);
			counter = arr1[0];
			arr1[1] = Math.max(arr1[1], arrtemp[1]);
			arr1[2] = Math.max(arr1[2], arrtemp[2]);
			arr1[3] = Math.min(arr1[3], arrtemp[3]);
			arr1[4] = Math.min(arr1[4], arrtemp[4]);
			
		}
		//right-arrow key
		arrtemp = directions( photo, row , column+1,target,counter+1);
		if (arrtemp[0] != -1 ) {
			arr1[0] = Math.max(arr1[0], arrtemp[0]);
			counter = arr1[0];
			arr1[1] = Math.max(arr1[1], arrtemp[1]);
			arr1[2] = Math.max(arr1[2], arrtemp[2]);
			arr1[3] = Math.min(arr1[3], arrtemp[3]);
			arr1[4] = Math.min(arr1[4], arrtemp[4]);
			
		}
		//left-arrow key
		arrtemp = directions( photo, row , column-1,target,counter+1);
		if (arrtemp[0] != -1 ) {
			arr1[0] = Math.max(arr1[0], arrtemp[0]);
			counter = arr1[0];
			arr1[1] = Math.max(arr1[1], arrtemp[1]);
			arr1[2] = Math.max(arr1[2], arrtemp[2]);
			arr1[3] = Math.min(arr1[3], arrtemp[3]);
			arr1[4] = Math.min(arr1[4], arrtemp[4]);
			
		}
		return arr1 ;
	}
	/*insertion sort on ListedArrays(took only the algorithm , hand edited to handle ListArrays)*/
	void sort(ArrayList<ArrayList<Integer>> arr){ 
	        int n = arr.size(); 
	        for (int i = 1; i < n; ++i) { 
	            ArrayList<Integer> key = arr.get(i); 
	            int j = i - 1;
	            while (j >= 0 && arr.get(j).get(0) >= key.get(0)) {
	            	if(arr.get(j).get(0) == key.get(0) && arr.get(j).get(1) < key.get(1)) {
	            		break;
	            	}
	                arr.set(j+1, arr.get(j)); 
	                j = j - 1; 
	            } 
	            arr.set(j+1,  key); 
	        } 
	}
}
